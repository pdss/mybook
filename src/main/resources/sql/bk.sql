/*
Navicat MySQL Data Transfer

Source Server         : 本机数据库
Source Server Version : 80011
Source Host           : localhost:3306
Source Database       : bk

Target Server Type    : MYSQL
Target Server Version : 80011
File Encoding         : 65001

Date: 2019-09-21 12:11:40
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '文章标题',
  `category` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '文章种类',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `author` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '作者',
  `read_num` int(11) DEFAULT '0' COMMENT '阅读数',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '文章主体',
  `comment_num` int(200) DEFAULT '0' COMMENT '评论数',
  PRIMARY KEY (`id`),
  KEY `id_key` (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', 'SpringCloud教程第1篇：Eureka', 'SpringCloud', '2019-03-17 19:15:48', '网络', '0', '一、spring cloud简介\r\n鉴于《史上最简单的Spring Cloud教程》很受读者欢迎，再次我特意升级了一下版本，目前支持的版本为Spring Boot版本2.0.3.RELEASE,Spring Cloud版本为Finchley.RELEASE。\r\n\r\nFinchley版本的官方文档如下： http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\nspring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：2小时学会springboot。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。\r\n\r\n二、创建服务注册中心\r\n在这里，我还是采用Eureka作为服务注册与发现的组件，至于Consul 之后会出文章详细介绍。\r\n\r\n2.1 首先创建一个maven主工程。\r\n\r\n首先创建一个主Maven工程，在其pom文件引入依赖，spring Boot版本为2.0.3.RELEASE，Spring Cloud版本为Finchley.RELEASE。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他module工程继承该pom。这一系列文章全部采用这种模式，其他文章的pom跟这个pom一样。再次说明一下，以后不再重复引入。代码如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>sc-f-chapter1</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>pom</packaging>\r\n\r\n    <name>sc-f-chapter1</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.0.3.RELEASE</version>\r\n        <relativePath/>\r\n    </parent>\r\n\r\n    <modules>\r\n        <module>eureka-server</module>\r\n        <module>service-hi</module>\r\n    </modules>\r\n\r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\r\n        <java.version>1.8</java.version>\r\n        <spring-cloud.version>Finchley.RELEASE</spring-cloud.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <dependencyManagement>\r\n        <dependencies>\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-dependencies</artifactId>\r\n                <version>${spring-cloud.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n\r\n\r\n2.2 然后创建2个model工程:一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。\r\n\r\n下面以创建server为例子，详细说明创建过程：\r\n\r\n右键工程->创建model-> 选择spring initialir 如下图：\r\n\r\nPaste_Image.png\r\n\r\n下一步->选择cloud discovery->eureka server ,然后一直下一步就行了。\r\n\r\nPaste_Image.png\r\n\r\n创建完后的工程，其pom.xml继承了父pom文件，并引入spring-cloud-starter-netflix-eureka-server的依赖，代码如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>eureka-server</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <name>eureka-server</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <parent>\r\n        <groupId>com.forezp</groupId>\r\n        <artifactId>sc-f-chapter1</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n    </parent>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n\r\n\r\n2.3 启动一个服务注册中心，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加：\r\n\r\n\r\n@SpringBootApplication\r\n@EnableEurekaServer\r\npublic class EurekaServerApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( EurekaServerApplication.class, args );\r\n    }\r\n}\r\n\r\n\r\n**2.4 **eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml：\r\n\r\nserver:\r\n  port: 8761\r\n\r\neureka:\r\n  instance:\r\n    hostname: localhost\r\n  client:\r\n    registerWithEureka: false\r\n    fetchRegistry: false\r\n    serviceUrl:\r\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\r\n\r\nspring:\r\n  application:\r\n    name: eurka-server\r\n      \r\n通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.\r\n\r\n2.5 eureka server 是有界面的，启动工程,打开浏览器访问： http://localhost:8761 ,界面如下：\r\n\r\nPaste_Image.png\r\n\r\nNo application available 没有服务被发现 ……^_^ 因为没有注册服务当然不可能有服务被发现了。\r\n\r\n三、创建一个服务提供者 (eureka client)\r\n当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。\r\n\r\n创建过程同server类似,创建完pom.xml如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>service-hi</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <name>service-hi</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <parent>\r\n        <groupId>com.forezp</groupId>\r\n        <artifactId>sc-f-chapter1</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n    </parent>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n\r\n</project>\r\n\r\n\r\n通过注解@EnableEurekaClient 表明自己是一个eurekaclient.\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@RestController\r\npublic class ServiceHiApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceHiApplication.class, args );\r\n    }\r\n\r\n    @Value(\"${server.port}\")\r\n    String port;\r\n\r\n    @RequestMapping(\"/hi\")\r\n    public String home(@RequestParam(value = \"name\", defaultValue = \"forezp\") String name) {\r\n        return \"hi \" + name + \" ,i am from port:\" + port;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下：\r\n\r\nserver:\r\n  port: 8762\r\n\r\nspring:\r\n  application:\r\n    name: service-hi\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://localhost:8761/eureka/\r\n\r\n\r\n需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。 启动工程，打开http://localhost:8761 ，即eureka server 的网址：\r\n\r\nPaste_Image.png\r\n\r\n你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862\r\n\r\n这时打开 http://localhost:8762/hi?name=forezp ，你会在浏览器上看到 :\r\n\r\nhi forezp,i am from port:8762\r\n\r\n源码下载：https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter1\r\n\r\n四、参考资料\r\nhttp://blog.csdn.net/forezp/article/details/69696915\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/01/sc-f1-eureka.html \r\n', '0');
INSERT INTO `article` VALUES ('2', 'SpringCloud教程第2篇：Ribbon', 'SpringCloud', '2019-03-17 19:16:50', '网络', '0', '在上一篇文章，讲了服务的注册和发现。在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。\r\n\r\n一、ribbon简介\r\nRibbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.\r\n\r\n—–摘自官网\r\n\r\nribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。\r\n\r\nribbon 已经默认实现了这些配置bean：\r\n\r\nIClientConfig ribbonClientConfig: DefaultClientConfigImpl\r\n\r\nIRule ribbonRule: ZoneAvoidanceRule\r\n\r\nIPing ribbonPing: NoOpPing\r\n\r\nServerList ribbonServerList: ConfigurationBasedServerList\r\n\r\nServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter\r\n\r\nILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer\r\n\r\n二、准备工作\r\n这一篇文章基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时你会发现：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。\r\n\r\n如何在idea下启动多个实例，请参照这篇文章： https://blog.csdn.net/forezp/article/details/76408139\r\n\r\n访问localhost:8761如图所示： 如何一个工程启动多个实例，请看这篇文章:https://blog.csdn.net/forezp/article/details/76408139\r\n\r\n\r\n\r\n三、建一个服务消费者\r\n重新新建一个spring-boot工程，取名为：service-ribbon; 在它的pom.xml继承了父pom文件，并引入了以下依赖：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>service-ribbon</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <name>service-ribbon</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n\r\n    <parent>\r\n        <groupId>com.forezp</groupId>\r\n        <artifactId>sc-f-chapter2</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n    </parent>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n \r\n\r\n</project>\r\n\r\n在工程的配置文件指定服务的注册中心地址为http://localhost:8761/eureka/，程序名称为 service-ribbon，程序端口为8764。配置文件application.yml如下：\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://localhost:8761/eureka/\r\nserver:\r\n  port: 8764\r\nspring:\r\n  application:\r\n    name: service-ribbon\r\n在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\npublic class ServiceRibbonApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceRibbonApplication.class, args );\r\n    }\r\n\r\n    @Bean\r\n    @LoadBalanced\r\n    RestTemplate restTemplate() {\r\n        return new RestTemplate();\r\n    }\r\n\r\n}\r\n\r\n\r\n写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下：\r\n\r\n@Service\r\npublic class HelloService {\r\n\r\n    @Autowired\r\n    RestTemplate restTemplate;\r\n\r\n    public String hiService(String name) {\r\n        return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class);\r\n    }\r\n\r\n\r\n}\r\n\r\n写一个controller，在controller中用调用HelloService 的方法，代码如下：\r\n\r\n\r\n@RestController\r\npublic class HelloControler {\r\n\r\n    @Autowired\r\n    HelloService helloService;\r\n\r\n    @GetMapping(value = \"/hi\")\r\n    public String hi(@RequestParam String name) {\r\n        return helloService.hiService( name );\r\n    }\r\n}\r\n\r\n\r\n在浏览器上多次访问http://localhost:8764/hi?name=forezp，浏览器交替显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\nhi forezp,i am from port:8763\r\n\r\n这说明当我们通过调用restTemplate.getForObject(“http://SERVICE-HI/hi?name=”+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。\r\n\r\n四、此时的架构\r\n此时架构图.png\r\n\r\n一个服务注册中心，eureka server,端口为8761\r\nservice-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册\r\nsercvice-ribbon端口为8764,向服务注册中心注册\r\n当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；\r\n源码下载：https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter2\r\n\r\n五、参考资料\r\n本文参考了以下：\r\n\r\nhttp://blog.csdn.net/forezp/article/details/69788938\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/02/sc-f2-ribbon.html \r\n', '0');
INSERT INTO `article` VALUES ('3', 'SpringCloud教程第3篇：feign', 'SpringCloud', '2019-03-17 19:17:31', '网络', '0', '上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。\r\n\r\n一、Feign简介\r\nFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\r\n简而言之：\r\n\r\nFeign 采用的是基于接口的注解\r\nFeign 整合了ribbon，具有负载均衡的能力\r\n整合了Hystrix，具有熔断的能力\r\n二、准备工作\r\n继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.\r\n\r\n三、创建一个feign的服务\r\n新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-netflix-eureka-client、Web的起步依赖spring-boot-starter-web，代码如下：\r\n\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>service-feign</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <name>service-feign</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n\r\n    <parent>\r\n        <groupId>com.forezp</groupId>\r\n        <artifactId>sc-f-chapter3</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n    </parent>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n    \r\n    </project>\r\n在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ ，代码如下：\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://localhost:8761/eureka/\r\nserver:\r\n  port: 8765\r\nspring:\r\n  application:\r\n    name: service-feign\r\n\r\n在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\n@EnableFeignClients\r\npublic class ServiceFeignApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceFeignApplication.class, args );\r\n    }\r\n}\r\n\r\n\r\n\r\n定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口，代码如下：\r\n\r\n\r\n@FeignClient(value = \"service-hi\")\r\npublic interface SchedualServiceHi {\r\n    @RequestMapping(value = \"/hi\",method = RequestMethod.GET)\r\n    String sayHiFromClientOne(@RequestParam(value = \"name\") String name);\r\n}\r\n\r\n\r\n\r\n\r\n在Web层的controller层，对外暴露一个”/hi”的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务。代码如下：\r\n\r\n@RestController\r\npublic class HiController {\r\n\r\n\r\n    //编译器报错，无视。 因为这个Bean是在程序启动的时候注入的，编译器感知不到，所以报错。\r\n    @Autowired\r\n    SchedualServiceHi schedualServiceHi;\r\n\r\n    @GetMapping(value = \"/hi\")\r\n    public String sayHi(@RequestParam String name) {\r\n        return schedualServiceHi.sayHiFromClientOne( name );\r\n    }\r\n}\r\n\r\n\r\n启动程序，多次访问http://localhost:8765/hi?name=forezp,浏览器交替显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\nhi forezp,i am from port:8763\r\n\r\nFeign源码解析：http://blog.csdn.net/forezp/article/details/73480304\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter3\r\n\r\n五、参考资料\r\n本文参考了以下：\r\n\r\nhttp://blog.csdn.net/forezp/article/details/69808079\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/03/sc-f3-feign.html \r\n', '0');
INSERT INTO `article` VALUES ('4', 'SpringCloud教程第4篇：Hystrix', 'SpringCloud', '2019-03-17 19:18:18', '网络', '0', '在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\r\n\r\n为了解决这个问题，业界提出了断路器模型。\r\n\r\n一、断路器简介\r\nNetflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.\r\n\r\n. —-摘自官网\r\n\r\nNetflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：\r\n\r\nHystrixGraph.png\r\n\r\n较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。\r\n\r\nHystrixFallback.png\r\n\r\n断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。\r\n\r\n二、准备工作\r\n这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。\r\n\r\n三、在ribbon使用断路器\r\n改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-netflix-hystrix的起步依赖：\r\n\r\n<dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n  </dependency>\r\n在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix：\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\n@EnableHystrix\r\npublic class ServiceRibbonApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceRibbonApplication.class, args );\r\n    }\r\n\r\n    @Bean\r\n    @LoadBalanced\r\n    RestTemplate restTemplate() {\r\n        return new RestTemplate();\r\n    }\r\n\r\n}\r\n\r\n改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：\r\n\r\n@Service\r\npublic class HelloService {\r\n\r\n    @Autowired\r\n    RestTemplate restTemplate;\r\n\r\n    @HystrixCommand(fallbackMethod = \"hiError\")\r\n    public String hiService(String name) {\r\n        return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\"+name,String.class);\r\n    }\r\n\r\n    public String hiError(String name) {\r\n        return \"hi,\"+name+\",sorry,error!\";\r\n    }\r\n\r\n}\r\n\r\n启动：service-ribbon 工程，当我们访问http://localhost:8764/hi?name=forezp,浏览器显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\n此时关闭 service-hi 工程，当我们再访问http://localhost:8764/hi?name=forezp，浏览器会显示：\r\n\r\nhi ,forezp,orry,error!\r\n\r\n这就说明当 service-hi 工程不可用的时候，service-ribbon调用 service-hi的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。\r\n\r\n四、Feign中使用断路器\r\nFeign是自带断路器的，在D版本的Spring Cloud之后，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：\r\n\r\nfeign.hystrix.enabled=true\r\n\r\n基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类就行了：\r\n\r\n@FeignClient(value = \"service-hi\",fallback = SchedualServiceHiHystric.class)\r\npublic interface SchedualServiceHi {\r\n    @RequestMapping(value = \"/hi\",method = RequestMethod.GET)\r\n    String sayHiFromClientOne(@RequestParam(value = \"name\") String name);\r\n}\r\n\r\nSchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中，代码如下：\r\n\r\n@Component\r\npublic class SchedualServiceHiHystric implements SchedualServiceHi {\r\n    @Override\r\n    public String sayHiFromClientOne(String name) {\r\n        return \"sorry \"+name;\r\n    }\r\n}\r\n\r\n启动四servcie-feign工程，浏览器打开http://localhost:8765/hi?name=forezp,注意此时service-hi工程没有启动，网页显示：\r\n\r\nsorry forezp\r\n\r\n打开service-hi工程，再次访问，浏览器显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\n这证明断路器起到作用了。\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter4\r\n\r\n六、参考资料\r\nhttp://blog.csdn.net/forezp/article/details/69934399\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/04/sc-f4-hystrix.html \r\n', '0');
INSERT INTO `article` VALUES ('5', 'SpringCloud教程第5篇：Zuul', 'SpringCloud', '2019-03-17 19:18:52', '网络', '0', '在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：\r\n\r\nAzure (1).png注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。 在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。\r\n\r\n一、Zuul简介\r\nZuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。\r\n\r\nzuul有以下功能：\r\n\r\nAuthentication\r\nInsights\r\nStress Testing\r\nCanary Testing\r\nDynamic Routing\r\nService Migration\r\nLoad Shedding\r\nSecurity\r\nStatic Response handling\r\nActive/Active traffic management\r\n二、准备工作\r\n继续使用上一节的工程。在原有的工程上，创建一个新的工程。\r\n\r\n三、创建service-zuul工程\r\n其pom.xml文件如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>service-zuul</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>jar</packaging>\r\n\r\n    <name>service-zuul</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <parent>\r\n        <groupId>com.forezp</groupId>\r\n        <artifactId>sc-f-chapter5</artifactId>\r\n        <version>0.0.1-SNAPSHOT</version>\r\n    </parent>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n</project>\r\n\r\n\r\n在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：\r\n\r\n@SpringBootApplication\r\n@EnableZuulProxy\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\npublic class ServiceZuulApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceZuulApplication.class, args );\r\n    }\r\n}\r\n\r\n\r\n加上配置文件application.yml加上以下的配置代码：\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://localhost:8761/eureka/\r\nserver:\r\n  port: 8769\r\nspring:\r\n  application:\r\n    name: service-zuul\r\nzuul:\r\n  routes:\r\n    api-a:\r\n      path: /api-a/**\r\n      serviceId: service-ribbon\r\n    api-b:\r\n      path: /api-b/**\r\n      serviceId: service-feign\r\n\r\n首先指定服务注册中心的地址为http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；\r\n\r\n依次运行这五个工程;打开浏览器访问：http://localhost:8769/api-a/hi?name=forezp ;浏览器显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\n打开浏览器访问：http://localhost:8769/api-b/hi?name=forezp ;浏览器显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\n这说明zuul起到了路由的作用\r\n\r\n四、服务过滤\r\nzuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；\r\n\r\n@Component\r\npublic class MyFilter extends ZuulFilter {\r\n\r\n    private static Logger log = LoggerFactory.getLogger(MyFilter.class);\r\n    @Override\r\n    public String filterType() {\r\n        return \"pre\";\r\n    }\r\n\r\n    @Override\r\n    public int filterOrder() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public boolean shouldFilter() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public Object run() {\r\n        RequestContext ctx = RequestContext.getCurrentContext();\r\n        HttpServletRequest request = ctx.getRequest();\r\n        log.info(String.format(\"%s >>> %s\", request.getMethod(), request.getRequestURL().toString()));\r\n        Object accessToken = request.getParameter(\"token\");\r\n        if(accessToken == null) {\r\n            log.warn(\"token is empty\");\r\n            ctx.setSendZuulResponse(false);\r\n            ctx.setResponseStatusCode(401);\r\n            try {\r\n                ctx.getResponse().getWriter().write(\"token is empty\");\r\n            }catch (Exception e){}\r\n\r\n            return null;\r\n        }\r\n        log.info(\"ok\");\r\n        return null;\r\n    }\r\n}\r\nfilterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：\r\npre：路由之前\r\nrouting：路由之时\r\npost： 路由之后\r\nerror：发送错误调用\r\nfilterOrder：过滤的顺序\r\nshouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。\r\nrun：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。\r\n这时访问：http://localhost:8769/api-a/hi?name=forezp ；网页显示：\r\n\r\ntoken is empty\r\n\r\n访问 http://localhost:8769/api-a/hi?name=forezp&token=22 ； 网页显示：\r\n\r\nhi forezp,i am from port:8762\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter5\r\n\r\n五、参考资料：\r\nhttp://blog.csdn.net/forezp/article/details/69939114\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/05/sc-f5-zuul.html \r\n', '0');
INSERT INTO `article` VALUES ('6', 'SpringCloud教程第6篇：config', 'SpringCloud', '2019-03-17 19:19:29', '网络', '0', '在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。\r\n\r\n一、简介\r\n在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。\r\n二、构建Config Server\r\n父maven工程省略，父pom文件：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.forezp</groupId>\r\n    <artifactId>sc-f-chapter6</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <packaging>pom</packaging>\r\n\r\n    <modules>\r\n        <module>config-server</module>\r\n        <module>config-client</module>\r\n    </modules>\r\n\r\n    <name>sc-f-chapter6</name>\r\n    <description>Demo project for Spring Boot</description>\r\n\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.0.3.RELEASE</version>\r\n        <relativePath/>\r\n    </parent>\r\n\r\n   \r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\r\n        <java.version>1.8</java.version>\r\n        <spring-cloud.version>Finchley.RELEASE</spring-cloud.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <dependencyManagement>\r\n        <dependencies>\r\n            <dependency>\r\n                <groupId>org.springframework.cloud</groupId>\r\n                <artifactId>spring-cloud-dependencies</artifactId>\r\n                <version>${spring-cloud.version}</version>\r\n                <type>pom</type>\r\n                <scope>import</scope>\r\n            </dependency>\r\n        </dependencies>\r\n    </dependencyManagement>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n\r\n</project>\r\n\r\n创建一个spring-boot项目，取名为config-server,其pom.xml如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n	<modelVersion>4.0.0</modelVersion>\r\n\r\n	<groupId>com.forezp</groupId>\r\n	<artifactId>config-server</artifactId>\r\n	<version>0.0.1-SNAPSHOT</version>\r\n	<packaging>jar</packaging>\r\n\r\n	<name>config-server</name>\r\n	<description>Demo project for Spring Boot</description>\r\n\r\n	<parent>\r\n		<groupId>com.forezp</groupId>\r\n		<artifactId>sc-f-chapter6</artifactId>\r\n		<version>0.0.1-SNAPSHOT</version>\r\n	</parent>\r\n\r\n	<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-config-server</artifactId>\r\n		</dependency>\r\n	</dependencies>\r\n	<build>\r\n		<plugins>\r\n			<plugin>\r\n				<groupId>org.springframework.boot</groupId>\r\n				<artifactId>spring-boot-maven-plugin</artifactId>\r\n			</plugin>\r\n		</plugins>\r\n	</build>\r\n\r\n\r\n</project>\r\n\r\n在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：\r\n\r\n\r\n@SpringBootApplication\r\n@EnableConfigServer\r\npublic class ConfigServerApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(ConfigServerApplication.class, args);\r\n	}\r\n}\r\n\r\n\r\n需要在程序的配置文件application.properties文件配置以下：\r\n\r\nspring.application.name=config-server\r\nserver.port=8888\r\n\r\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\r\nspring.cloud.config.server.git.searchPaths=respo\r\nspring.cloud.config.label=master\r\nspring.cloud.config.server.git.username=\r\nspring.cloud.config.server.git.password=\r\n\r\n\r\n\r\nspring.cloud.config.server.git.uri：配置git仓库地址\r\nspring.cloud.config.server.git.searchPaths：配置仓库路径\r\nspring.cloud.config.label：配置仓库的分支\r\nspring.cloud.config.server.git.username：访问git仓库的用户名\r\nspring.cloud.config.server.git.password：访问git仓库的用户密码\r\n如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。\r\n\r\n远程仓库https://github.com/forezp/SpringcloudConfig/ 中有个文件config-client-dev.properties文件中有一个属性：\r\n\r\nfoo = foo version 3\r\n\r\n启动程序：访问http://localhost:8888/foo/dev\r\n\r\n{\"name\":\"foo\",\"profiles\":[\"dev\"],\"label\":\"master\",\r\n\"version\":\"792ffc77c03f4b138d28e89b576900ac5e01a44b\",\"state\":null,\"propertySources\":[]}\r\n\r\n证明配置服务中心可以从远程程序获取配置信息。\r\n\r\nhttp请求地址和资源文件映射如下:\r\n\r\n/{application}/{profile}[/{label}]\r\n/{application}-{profile}.yml\r\n/{label}/{application}-{profile}.yml\r\n/{application}-{profile}.properties\r\n/{label}/{application}-{profile}.properties\r\n三、构建一个config client\r\n重新创建一个springboot项目，取名为config-client,其pom文件：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n	<modelVersion>4.0.0</modelVersion>\r\n\r\n	<groupId>com.forezp</groupId>\r\n	<artifactId>config-client</artifactId>\r\n	<version>0.0.1-SNAPSHOT</version>\r\n	<packaging>jar</packaging>\r\n\r\n	<name>config-client</name>\r\n	<description>Demo project for Spring Boot</description>\r\n\r\n	<parent>\r\n		<groupId>com.forezp</groupId>\r\n		<artifactId>sc-f-chapter6</artifactId>\r\n		<version>0.0.1-SNAPSHOT</version>\r\n	</parent>\r\n\r\n	<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-config</artifactId>\r\n		</dependency>\r\n	</dependencies>\r\n\r\n	<build>\r\n		<plugins>\r\n			<plugin>\r\n				<groupId>org.springframework.boot</groupId>\r\n				<artifactId>spring-boot-maven-plugin</artifactId>\r\n			</plugin>\r\n		</plugins>\r\n	</build>\r\n\r\n\r\n</project>\r\n\r\n其配置文件bootstrap.properties：\r\n\r\nspring.application.name=config-client\r\nspring.cloud.config.label=master\r\nspring.cloud.config.profile=dev\r\nspring.cloud.config.uri= http://localhost:8888/\r\nserver.port=8881\r\n\r\nspring.cloud.config.label 指明远程仓库的分支\r\nspring.cloud.config.profile\r\ndev开发环境配置文件\r\ntest测试环境\r\npro正式环境\r\nspring.cloud.config.uri= http://localhost:8888/ 指明配置服务中心的网址。\r\n程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：\r\n\r\n@SpringBootApplication\r\n@RestController\r\npublic class ConfigClientApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(ConfigClientApplication.class, args);\r\n	}\r\n\r\n	@Value(\"${foo}\")\r\n	String foo;\r\n	@RequestMapping(value = \"/hi\")\r\n	public String hi(){\r\n		return foo;\r\n	}\r\n}\r\n\r\n\r\n打开网址访问：http://localhost:8881/hi，网页显示：\r\n\r\nfoo version 3\r\n\r\n这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：\r\n\r\nAzure (2).png\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter6\r\n\r\n四、参考资料\r\nhttp://blog.csdn.net/forezp/article/details/70037291\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/06/sc-f6-config.html \r\n', '0');
INSERT INTO `article` VALUES ('7', 'SpringCloud教程第7篇：高可用的分布式配置中心', 'SpringCloud', '2019-03-17 19:20:09', '网络', '0', '上一篇文章讲述了一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用，架构图如下：\r\n\r\nAzure (3).png\r\n一、准备工作\r\n继续使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。\r\n\r\n在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-netflix- eureka-server，代码如下:\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n	<modelVersion>4.0.0</modelVersion>\r\n\r\n	<groupId>com.forezp</groupId>\r\n	<artifactId>config-server</artifactId>\r\n	<version>0.0.1-SNAPSHOT</version>\r\n	<packaging>jar</packaging>\r\n\r\n	<name>config-server</name>\r\n	<description>Demo project for Spring Boot</description>\r\n\r\n	<parent>\r\n		<groupId>com.forezp</groupId>\r\n		<artifactId>sc-f-chapter7</artifactId>\r\n		<version>0.0.1-SNAPSHOT</version>\r\n	</parent>\r\n\r\n	<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-config-server</artifactId>\r\n		</dependency>\r\n\r\n	</dependencies>\r\n	<build>\r\n		<plugins>\r\n			<plugin>\r\n				<groupId>org.springframework.boot</groupId>\r\n				<artifactId>spring-boot-maven-plugin</artifactId>\r\n			</plugin>\r\n		</plugins>\r\n	</build>\r\n\r\n\r\n\r\n</project>\r\n\r\n\r\n在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置，代码如下：\r\n\r\nserver:\r\n  port: 8889\r\n\r\neureka:\r\n  instance:\r\n    hostname: localhost\r\n  client:\r\n    registerWithEureka: false\r\n    fetchRegistry: false\r\n    serviceUrl:\r\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\r\n入口类：\r\n\r\n@EnableEurekaServer\r\n@SpringBootApplication\r\npublic class EurekaServerApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(EurekaServerApplication.class, args);\r\n	}\r\n}\r\n\r\n\r\n二、改造config-server\r\n在其pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-netflix-eureka-client，代码如下:\r\n\r\n<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-config-server</artifactId>\r\n		</dependency>\r\n\r\n	</dependencies>\r\n配置文件application.yml，指定服务注册地址为http://localhost:8889/eureka/，其他配置同上一篇文章，完整的配置如下：\r\n\r\nspring.application.name=config-server\r\nserver.port=8888\r\n\r\nspring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/\r\nspring.cloud.config.server.git.searchPaths=respo\r\nspring.cloud.config.label=master\r\nspring.cloud.config.server.git.username= your username\r\nspring.cloud.config.server.git.password= your password\r\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\r\n最后需要在程序的启动类Application加上@EnableEureka的注解。\r\n\r\n三、改造config-client\r\n将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-netflix-eureka-client，代码如下：\r\n\r\n<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-config</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n		</dependency>\r\n	</dependencies>\r\n配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为http://localhost:8889/eureka/\r\n\r\nspring.application.name=config-client\r\nspring.cloud.config.label=master\r\nspring.cloud.config.profile=dev\r\n#spring.cloud.config.uri= http://localhost:8888/\r\n\r\neureka.client.serviceUrl.defaultZone=http://localhost:8889/eureka/\r\nspring.cloud.config.discovery.enabled=true\r\nspring.cloud.config.discovery.serviceId=config-server\r\nserver.port=8881\r\n\r\n\r\nspring.cloud.config.discovery.enabled 是从配置中心读取文件。\r\nspring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。\r\n这时发现，在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。\r\n\r\n依次启动eureka-servr,config-server,config-client 访问网址：http://localhost:8889/\r\n\r\nPaste_Image.png\r\n\r\n访问http://localhost:8881/hi，浏览器显示：\r\n\r\nfoo version 3\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter7\r\n\r\n四、参考资料\r\nspring_cloud_config\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/07/sc-f7-config.html \r\n', '0');
INSERT INTO `article` VALUES ('8', 'SpringCloud教程第8篇：Spring Cloud Bus', 'SpringCloud', '2019-03-17 19:20:41', '网络', '3', 'Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。\r\n\r\n一、准备工作\r\n本文还是基于上一篇文章来实现。按照官方文档，我们只需要在配置文件中配置 spring-cloud-starter-bus-amqp ；这就是说我们需要装rabbitMq，点击rabbitmq下载。至于怎么使用 rabbitmq，搜索引擎下。\r\n\r\n二、改造config-client\r\n在pom文件加上起步依赖spring-cloud-starter-bus-amqp，完整的配置文件如下：\r\n\r\n<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-config</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-bus-amqp</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-actuator</artifactId>\r\n		</dependency>\r\n\r\n\r\n在配置文件application.properties中加上RabbitMq的配置，包括RabbitMq的地址、端口，用户名、密码。并需要加上spring.cloud.bus的三个配置，具体如下：\r\n\r\n\r\nspring.rabbitmq.host=localhost\r\nspring.rabbitmq.port=5672\r\nspring.rabbitmq.username=guest\r\nspring.rabbitmq.password=guest\r\n\r\nspring.cloud.bus.enabled=true\r\nspring.cloud.bus.trace.enabled=true\r\nmanagement.endpoints.web.exposure.include=bus-refresh\r\n\r\n\r\nConfigClientApplication启动类代码如下：\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\n@RestController\r\n@RefreshScope\r\npublic class ConfigClientApplication {\r\n\r\n	/**\r\n	 * http://localhost:8881/actuator/bus-refresh\r\n	 */\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(ConfigClientApplication.class, args);\r\n	}\r\n\r\n	@Value(\"${foo}\")\r\n	String foo;\r\n\r\n	@RequestMapping(value = \"/hi\")\r\n	public String hi(){\r\n		return foo;\r\n	}\r\n}\r\n\r\n\r\n依次启动eureka-server、confg-cserver,启动两个config-client，端口为：8881、8882。\r\n\r\n访问http://localhost:8881/hi 或者http://localhost:8882/hi 浏览器显示：\r\n\r\nfoo version 3\r\n\r\n这时我们去代码仓库将foo的值改为“foo version 4”，即改变配置文件foo的值。如果是传统的做法，需要重启服务，才能达到配置文件的更新。此时，我们只需要发送post请求：http://localhost:8881/actuator/bus-refresh，你会发现config-client会重新读取配置文件\r\n\r\nPaste_Image.png\r\n\r\n重新读取配置文件：\r\n\r\nPaste_Image.png\r\n\r\n这时我们再访问http://localhost:8881/hi 或者http://localhost:8882/hi 浏览器显示：\r\n\r\nfoo version 4\r\n\r\n另外，/actuator/bus-refresh接口可以指定服务，即使用”destination”参数，比如 “/actuator/bus-refresh?destination=customers:**” 即刷新服务名为customers的所有服务。\r\n\r\n三、分析\r\n此时的架构图： Paste_Image.png\r\n\r\n当git文件更改的时候，通过pc端用post 向端口为8882的config-client发送请求/bus/refresh／；此时8882端口会发送一个消息，由消息总线向其他服务传递，从而使整个微服务集群都达到更新配置文件。\r\n\r\n本文源码下载：\r\nhttps://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter8\r\n\r\n五、参考资料\r\nhttp://blog.csdn.net/forezp/article/details/70148235\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/08/sc-f8-bus.html \r\n', '0');
INSERT INTO `article` VALUES ('9', 'SpringCloud教程第9篇：Sleuth', 'SpringCloud', '2019-03-17 19:21:17', '网络', '0', '这篇文章主要讲述服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。\r\n\r\n一、简介\r\nAdd sleuth to the classpath of a Spring Boot application (see below for Maven and Gradle examples), and you will see the correlation data being collected in logs, as long as you are logging requests.\r\n\r\n—— 摘自官网\r\n\r\nSpring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。\r\n\r\n二、服务追踪分析\r\n微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。\r\n\r\nPaste_Image.png\r\n\r\n随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：\r\n\r\nPaste_Image.png\r\n\r\n三、术语\r\nSpan：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。\r\nTrace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。\r\nAnnotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束\r\ncs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始\r\nsr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟\r\nss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间\r\ncr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化：\r\n将Span和Trace在一个系统中使用Zipkin注解的过程图形化：\r\n\r\nPaste_Image.png\r\n\r\n四、构建工程\r\n基本知识讲解完毕，下面我们来实战，本文的案例主要有三个工程组成:一个server-zipkin,它的主要作用使用ZipkinServer 的功能，收集调用数据，并展示；一个service-hi,对外暴露hi接口；一个service-miya,对外暴露miya接口；这两个service可以相互调用；并且只有调用了，server-zipkin才会收集数据的，这就是为什么叫服务追踪了。\r\n\r\n4.1 构建server-zipkin\r\n在spring Cloud为F版本的时候，已经不需要自己构建Zipkin Server了，只需要下载jar即可，下载地址：\r\n\r\nhttps://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/\r\n\r\n也可以在这里https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter9 下载。下载完成jar 包之后，需要运行jar，如下：\r\n\r\njava -jar zipkin-server-2.10.1-exec.jar\r\n\r\n访问浏览器localhost:9494\r\n\r\n4.2 创建service-hi\r\n在其pom引入起步依赖spring-cloud-starter-zipkin，代码如下：\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n		 xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n	<modelVersion>4.0.0</modelVersion>\r\n\r\n	<groupId>com.forezp</groupId>\r\n	<artifactId>service-zipkin</artifactId>\r\n	<version>0.0.1-SNAPSHOT</version>\r\n	<packaging>jar</packaging>\r\n\r\n	<name>service-hi</name>\r\n	<description>Demo project for Spring Boot</description>\r\n\r\n	<parent>\r\n		<groupId>com.forezp</groupId>\r\n		<artifactId>sc-f-chapter9</artifactId>\r\n		<version>0.0.1-SNAPSHOT</version>\r\n	</parent>\r\n\r\n\r\n\r\n	<dependencies>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-web</artifactId>\r\n		</dependency>\r\n\r\n		<dependency>\r\n			<groupId>org.springframework.cloud</groupId>\r\n			<artifactId>spring-cloud-starter-zipkin</artifactId>\r\n		</dependency>\r\n\r\n\r\n\r\n	</dependencies>\r\n\r\n	<build>\r\n		<plugins>\r\n			<plugin>\r\n				<groupId>org.springframework.boot</groupId>\r\n				<artifactId>spring-boot-maven-plugin</artifactId>\r\n			</plugin>\r\n		</plugins>\r\n	</build>\r\n\r\n</project>\r\n\r\n在其配置文件application.yml指定zipkin server的地址，头通过配置“spring.zipkin.base-url”指定：\r\n\r\n\r\n\r\nserver.port=8988\r\nspring.zipkin.base-url=http://localhost:9411\r\nspring.application.name=service-hi\r\n\r\n通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。\r\n\r\n对外暴露接口：\r\n\r\npackage com.forezp;\r\n\r\nimport brave.sampler.Sampler;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.client.RestTemplate;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\n\r\n@SpringBootApplication\r\n@RestController\r\npublic class ServiceHiApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(ServiceHiApplication.class, args);\r\n	}\r\n\r\n	private static final Logger LOG = Logger.getLogger(ServiceHiApplication.class.getName());\r\n\r\n\r\n	@Autowired\r\n	private RestTemplate restTemplate;\r\n\r\n	@Bean\r\n	public RestTemplate getRestTemplate(){\r\n		return new RestTemplate();\r\n	}\r\n\r\n	@RequestMapping(\"/hi\")\r\n	public String callHome(){\r\n		LOG.log(Level.INFO, \"calling trace service-hi  \");\r\n		return restTemplate.getForObject(\"http://localhost:8989/miya\", String.class);\r\n	}\r\n	@RequestMapping(\"/info\")\r\n	public String info(){\r\n		LOG.log(Level.INFO, \"calling trace service-hi \");\r\n\r\n		return \"i\'m service-hi\";\r\n\r\n	}\r\n\r\n	@Bean\r\n	public Sampler defaultSampler() {\r\n		return Sampler.ALWAYS_SAMPLE;\r\n	}\r\n\r\n\r\n}\r\n\r\n\r\n4.3 创建service-miya\r\n创建过程痛service-hi，引入相同的依赖，配置下spring.zipkin.base-url。\r\n\r\n对外暴露接口：\r\n\r\n\r\npackage com.forezp;\r\n\r\nimport brave.sampler.Sampler;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.client.RestTemplate;\r\n\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\n\r\n@SpringBootApplication\r\n@RestController\r\npublic class ServiceMiyaApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(ServiceMiyaApplication.class, args);\r\n	}\r\n\r\n	private static final Logger LOG = Logger.getLogger(ServiceMiyaApplication.class.getName());\r\n\r\n\r\n	@RequestMapping(\"/hi\")\r\n	public String home(){\r\n		LOG.log(Level.INFO, \"hi is being called\");\r\n		return \"hi i\'m miya!\";\r\n	}\r\n\r\n	@RequestMapping(\"/miya\")\r\n	public String info(){\r\n		LOG.log(Level.INFO, \"info is being called\");\r\n		return restTemplate.getForObject(\"http://localhost:8988/info\",String.class);\r\n	}\r\n\r\n	@Autowired\r\n	private RestTemplate restTemplate;\r\n\r\n	@Bean\r\n	public RestTemplate getRestTemplate(){\r\n		return new RestTemplate();\r\n	}\r\n\r\n\r\n	@Bean\r\n	public Sampler defaultSampler() {\r\n		return Sampler.ALWAYS_SAMPLE;\r\n	}\r\n}\r\n\r\n4.4 启动工程，演示追踪\r\n依次启动上面的工程，打开浏览器访问：http://localhost:9411/，会出现以下界面：\r\n\r\nPaste_Image.png\r\n\r\n访问：http://localhost:8989/miya，浏览器出现：\r\n\r\ni’m service-hi\r\n\r\n再打开http://localhost:9411/的界面，点击Dependencies,可以发现服务的依赖关系：\r\n\r\nPaste_Image.png\r\n\r\n点击find traces,可以看到具体服务相互调用的数据：\r\n\r\nPaste_Image.png\r\n\r\n本文源码下载：\r\n\r\nhttps://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter9\r\n\r\n五、参考资料\r\nspring-cloud-sleuth\r\n\r\nhttp://blog.csdn.net/forezp/article/details/70162074\r\n\r\nhttp://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/09/sc-f9-sleuth.html \r\n', '0');
INSERT INTO `article` VALUES ('10', 'SpringCloud教程第10篇：高可用的服务注册中心', 'SpringCloud', '2019-03-17 19:22:08', '网络', '0', '一、准备工作\r\nEureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid serviceUrl to a peer, e.g.\r\n\r\n摘自官网\r\n\r\nEureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。\r\n\r\n这篇文章我们基于第一篇文章的工程，来做修改。\r\n\r\n二、改造工作\r\n在eureka-server工程中resources文件夹下，创建配置文件application-peer1.yml:\r\n\r\nserver:\r\n  port: 8761\r\n\r\nspring:\r\n  profiles: peer1\r\neureka:\r\n  instance:\r\n    hostname: peer1\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://peer2:8769/eureka/\r\n\r\n并且创建另外一个配置文件application-peer2.yml：\r\n\r\n\r\nserver:\r\n  port: 8769\r\n\r\nspring:\r\n  profiles: peer2\r\neureka:\r\n  instance:\r\n    hostname: peer2\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://peer1:8761/eureka/\r\n\r\n这时eureka-server就已经改造完毕。\r\n\r\nou could use this configuration to test the peer awareness on a single host (there’s not much value in doing that in production) by manipulating /etc/hosts to resolve the host names.\r\n\r\n按照官方文档的指示，需要改变etc/hosts，linux系统通过vim /etc/hosts ,加上：\r\n\r\n127.0.0.1 peer1\r\n127.0.0.1 peer2\r\nwindows电脑，在c:/windows/systems/drivers/etc/hosts 修改。\r\n\r\n这时需要改造下service-hi:\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://peer1:8761/eureka/\r\nserver:\r\n  port: 8762\r\nspring:\r\n  application:\r\n    name: service-hi\r\n\r\n三、启动工程\r\n启动eureka-server：\r\n\r\njava -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer1\r\n\r\njava -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer2\r\n\r\n启动service-hi:\r\n\r\njava -jar service-hi-0.0.1-SNAPSHOT.jar\r\n\r\n访问：localhost:8761,如图：\r\n\r\nPaste_Image.png\r\n\r\n你会发现注册了service-hi，并且有个peer2节点，同理访问localhost:8769你会发现有个peer1节点。\r\n\r\nclient只向8761注册，但是你打开8769，你也会发现，8769也有 client的注册信息。\r\n\r\n个人感受：这是通过看官方文档的写的demo ，但是需要手动改host是不是不符合Spring Cloud 的高上大？\r\n\r\nPrefer IP Address\r\nIn some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and when the application registers with eureka, it will use its IP Address rather than its hostname.\r\n\r\n摘自官网\r\n\r\neureka.instance.preferIpAddress=true是通过设置ip让eureka让其他服务注册它。也许能通过去改变去通过改变host的方式。\r\n\r\n此时的架构图：\r\n\r\n有点丑e.png\r\n\r\nEureka-eserver peer1 8761,Eureka-eserver peer2 8769相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。\r\n\r\n本文源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter10\r\n\r\n四、参考文献\r\nhigh_availability_zones\r\n\r\nhttp://blog.csdn.net/forezp/article/details/70183572\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/10/sc-f10-eureka.html \r\n', '0');
INSERT INTO `article` VALUES ('11', 'SpringCloud教程第12篇：Hystrix Dashboard', 'SpringCloud', '2019-03-17 19:22:40', '网络', '0', '在我的第四篇文章断路器讲述了如何使用断路器，并简单的介绍了下Hystrix Dashboard组件，这篇文章更加详细的介绍Hystrix Dashboard。\r\n一、Hystrix Dashboard简介\r\n在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。\r\n\r\n二、准备工作\r\n本文的的工程栗子，来源于第一篇文章的栗子，在它的基础上进行改造。\r\n\r\n三、开始改造service-hi\r\n在pom的工程文件引入相应的依赖：\r\n\r\n<dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\r\n        </dependency>\r\n        \r\n    </dependencies>\r\n其中，这三个依赖是必须的，缺一不可。\r\n\r\n在程序的入口ServiceHiApplication类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\n@RestController\r\n@EnableHystrix\r\n@EnableHystrixDashboard\r\n@EnableCircuitBreaker\r\npublic class ServiceHiApplication {\r\n\r\n    /**\r\n     * 访问地址 http://localhost:8762/actuator/hystrix.stream\r\n     * @param args\r\n     */\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceHiApplication.class, args );\r\n    }\r\n\r\n    @Value(\"${server.port}\")\r\n    String port;\r\n\r\n    @RequestMapping(\"/hi\")\r\n    @HystrixCommand(fallbackMethod = \"hiError\")\r\n    public String home(@RequestParam(value = \"name\", defaultValue = \"forezp\") String name) {\r\n        return \"hi \" + name + \" ,i am from port:\" + port;\r\n    }\r\n\r\n    public String hiError(String name) {\r\n        return \"hi,\"+name+\",sorry,error!\";\r\n    }\r\n\r\n}\r\n运行程序： 依次开启eureka-server 和service-hi.\r\n\r\n四、Hystrix Dashboard图形展示\r\n打开http://localhost:8762/actuator/hystrix.stream，可以看到一些具体的数据：\r\n\r\n这里写图片描述\r\n\r\n打开locahost:8762/hystrix 可以看见以下界面：\r\n\r\n这里写图片描述\r\n\r\n在界面依次输入：http://localhost:8762/actuator/hystrix.stream 、2000 、miya ；点确定。\r\n\r\n在另一个窗口输入： http://localhost:8762/hi?name=forezp\r\n\r\n重新刷新hystrix.stream网页，你会看到良好的图形化界面：\r\n\r\n这里写图片描述\r\n\r\n源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter12\r\n\r\n五、参考资料\r\nhystrix-dashboard\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/12/sc-f12-dash.html \r\n', '0');
INSERT INTO `article` VALUES ('12', 'SpringCloud教程第13篇：Turbine', 'SpringCloud', '2019-03-17 19:23:16', '网络', '7', '上一篇文章讲述了如何利用Hystrix Dashboard去监控断路器的Hystrix command。当我们有很多个服务的时候，这就需要聚合所以服务的Hystrix Dashboard的数据了。这就需要用到Spring Cloud的另一个组件了，即Hystrix Turbine。\r\n一、Hystrix Turbine简介\r\n看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。\r\n\r\n二、准备工作\r\n本文使用的工程为上一篇文章的工程，在此基础上进行改造。因为我们需要多个服务的Dashboard，所以需要再建一个服务，取名为service-lucy，它的基本配置同service-hi，具体见源码,在这里就不详细说明。\r\n\r\n三、创建service-turbine\r\n引入相应的依赖：\r\n\r\n <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-actuator</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.cloud</groupId>\r\n            <artifactId>spring-cloud-starter-netflix-turbine</artifactId>\r\n        </dependency>\r\n\r\n    </dependencies>\r\n\r\n\r\n在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。\r\n\r\n\r\n@SpringBootApplication\r\n@EnableEurekaClient\r\n@EnableDiscoveryClient\r\n@RestController\r\n@EnableHystrix\r\n@EnableHystrixDashboard\r\n@EnableCircuitBreaker\r\n@EnableTurbine\r\npublic class ServiceTurbineApplication {\r\n\r\n    /**\r\n     * http://localhost:8764/turbine.stream\r\n     */\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run( ServiceTurbineApplication.class, args );\r\n    }\r\n}\r\n\r\n\r\n配置文件application.yml：\r\n\r\nserver:\r\n  port: 8764\r\n\r\nspring:\r\n  application:\r\n    name: service-turbine\r\n\r\neureka:\r\n  client:\r\n    serviceUrl:\r\n      defaultZone: http://localhost:8761/eureka/\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"*\"\r\n      cors:\r\n        allowed-origins: \"*\"\r\n        allowed-methods: \"*\"\r\n\r\nturbine:\r\n  app-config: service-hi,service-lucy\r\n  aggregator:\r\n    clusterConfig: default\r\n  clusterNameExpression: new String(\"default\")\r\n  combine-host: true\r\n  instanceUrlSuffix:\r\n    default: actuator/hystrix.stream     \r\n\r\n配置文件注解写的很清楚。\r\n\r\n四、Turbine演示\r\n依次开启eureka-server、service-hi、service-lucy、service-turbine工程。\r\n\r\n打开浏览器输入：http://localhost:8764/turbine.stream,界面如下：\r\n\r\n这里写图片描述\r\n\r\n依次请求：\r\n\r\nhttp://localhost:8762/hi?name=forezp\r\n\r\nhttp://localhost:8763/hi?name=forezp\r\n\r\n打开:http://localhost:8763/hystrix,输入监控流http://localhost:8764/turbine.stream\r\n\r\n这里写图片描述\r\n\r\n点击monitor stream 进入页面：\r\n\r\n这里写图片描述\r\n\r\n可以看到这个页面聚合了2个service的hystrix dashbord数据。\r\n\r\n源码下载： https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter13\r\n\r\n五、参考文献\r\nhystrix_dashboard\r\n\r\nturbine\r\n\r\n\r\n转载：https://www.fangzhipeng.com/springcloud/2018/08/13/sc-f13-turbine.html \r\n', '0');
INSERT INTO `article` VALUES ('13', 'springboot+mybatis+mysql+thmeleaf+pagehelper实现分页 ', 'springboot', '2019-03-17 20:04:51', '罗涛', '5', 'springboot的推荐模板引擎是thmeleaf。\r\n但是我昨天做分页的时候在网上没有找到有thmeleaf语法做分页的（大多是ajax）。\r\n所以我把我自己撸了一个例子。\r\n先是依赖：\r\n<dependency>\r\n            <groupId>com.github.pagehelper</groupId>\r\n            <artifactId>pagehelper-spring-boot-starter</artifactId>\r\n            <version>1.2.10</version>\r\n</dependency>\r\n\r\n然后是配置文件：\r\npagehelper:\r\n  helper-dialect: mysql\r\n  reasonable: true\r\n  support-methods-arguments: true\r\n  params: count=countSql\r\n\r\n然后是sql语句的写法：\r\n    @Select(\"select * from article order by id desc\")\r\n    Page<Article> getAllArticle();\r\n\r\ncontroller的写法：\r\n @GetMapping(\"/index\")\r\n    public String index(Model model,\r\n                        @RequestParam(value = \"pageNum\",defaultValue = \"1\")Integer pageNum,\r\n                        @RequestParam(value = \"pageSize\" ,defaultValue = \"5\")Integer pageSize){\r\n     1：   PageHelper.startPage(pageNum, pageSize);\r\n     2：   Page<Article> articles = articleService.getAllArticle();\r\n             model.addAttribute(\"articles\", articles);\r\n             return \"index\";\r\n值得注意的是： 第一句写完马山要接第二句。不然分页里面没有值。这是我遇到的问题，\r\n不一定每个人都一样。在这里做个笔记。\r\n\r\n然后是前台的thmeleaf写的分页：\r\n\r\n<div class=\"pagination\">\r\n                    <ul class=\"pagination pull-right\">\r\n                        <li><a href=\"javascript:return false;\" style=\"opacity: 0.2\" th:if=\"${articles.getPageNum()} eq \'1\'\">上一页</a></li>\r\n                        <li><a href=\"#\" th:if=\"${articles.getPageNum()} ne \'1\'\" th:href=\"@{\'/index?pageNum=\'+${articles.getPageNum()-1}}\">上一页</a></li>\r\n\r\n\r\n                        <li th:each=\"i:${#numbers.sequence(1,articles.getPages())}\">\r\n                            <a th:if=\"${articles.getPageNum()} ne ${i}\" th:href=\"@{\'/index?pageNum=\'+${i}}\" th:text=\"${i}\">1</a>\r\n                            <a th:if=\"${articles.getPageNum()} eq ${i}\" href=\"javascript:return false;\" style=\"opacity: 0.2\" th:text=\"${i}\">1</a>\r\n                        </li>\r\n\r\n                        <li><a href=\"javascript:return false;\" style=\"opacity: 0.2\" th:if=\"${articles.getPageNum()} eq ${articles.getPages()}\">下一页</a></li>\r\n                        <li><a href=\"#\"th:if=\"${articles.getPageNum()} ne ${articles.getPages()}\" th:href=\"@{\'/index?pageNum=\'+${articles.getPageNum()+1}}\">下一页</a></li>\r\n                    </ul>\r\n                </div>\r\n以上。\r\n\r\n       \r\n\r\n', '0');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a_id` int(11) NOT NULL COMMENT '文章id',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `content` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `star` int(11) NOT NULL DEFAULT '0' COMMENT '点赞',
  PRIMARY KEY (`id`),
  KEY `uqe_aid` (`a_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- ----------------------------
-- Records of comment
-- ----------------------------
